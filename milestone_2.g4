grammar milestone_2;

SPACE: ' ' -> skip;
NEWLINE: [\r\n]+ -> skip;

NOT_INDENT: (INDENT (SPACE|SPACE SPACE|SPACE SPACE SPACE) ) -> skip;
INDENT: '    '+ ;

OPERATOR :  OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 | OP10
        | OR | XOR | AND | IS | ISNOT | IN | NOTIN | OF | DIV | MOD | SHL | SHR | NOT | STATIC ;

OP2 : AT | COLON ;
OP3 : OR | XOR ;
OP4 : AND ;
OP5 : EQUALS_OPERATOR | LE_OPERATOR | LESS_THAN | GE_OPERATOR | GREATER_THAN | IN | NOTIN | IS 
    | ISNOT | NOT | OF ;
OP6 : '..';
OP7 : AND_OPERATOR ;
OP8 : ADD_OPERATOR | MINUS_OPERATOR ;
OP9 : MUL_OPERATOR | DIV_OPERATOR | DIV | MOD | SHL | SHR | MODULUS ;
OP10 : DOLLAR | XOR_OPERATOR;

OPT_IND : COMMENT? INDENT?;
OPT_PAR : (INDENT{>} | INDENT{=})?;

ASSIGN_EXPR : OR_EXPR (OP2 OPT_IND OR_EXPR)* ;
OR_EXPR : AND_EXPR (OP3 OPT_IND AND_EXPR)* ;
AND_EXPR : CMP_EXPR (OP4 OPT_IND CMP_EXPR)* ;
CMP_EXPR : SLICE_EXPR (OP5 OPT_IND SLICE_EXPR)* ;
SLICE_EXPR : AMP_EXPR (OP6 OPT_IND AMP_EXPR)* ;
AMP_EXPR : PLUS_EXPR (OP7 OPT_IND PLUS_EXPR)* ;
PLUS_EXPR : MUL_EXPR (OP8 OPT_IND MUL_EXPR)* ;
MUL_EXPR : DOLLAR_EXPR (OP9 OPT_IND DOLLAR_EXPR)* ;
DOLLAR_EXPR : PRIMARY (OP10 OPT_IND PRIMARY)* ;

PRIMARY :
          OPERATOR* IDENT_LIT 
        | BIND PRIMARY;

EXPR_COLON_EXPR : EXPR (':'|'=' EXPR)?;

EXPR : (BLOCK_EXPR
      | IF_EXPR
      | WHEN_EXPR
      | FOR_STMT);


COLCOM : COLON COMMENT?;
IF_EXPR: IF COND_EXPR;
IF_STMT: IF COND_STMT;
COND_EXPR: EXPR COLCOM EXPR OPT_IND
        (ELIF EXPR COLCOM EXPR OPT_IND)*
         ELSE COLCOM EXPR;
COND_STMT: EXPR COLCOM STMT COMMENT?
           (INDENT{=} ELIF EXPR COLCOM STMT)*
           (INDENT{=} ELSE COLCOM STMT)?;
WHEN_EXPR: WHEN COND_EXPR;
BLOCK_EXPR : BLOCK SYMBOL? COLCOM STMT;
//FOR_STMT: FOR (IDENT_PRAGMA ) IN EXPR COLCOM STMT;

PRAGMA : OPEN_BRACE DOT OPT_IND (EXPR_COLON_EXPR COMMA?)* OPT_PAR (DOT CLOSE_BRACE | CLOSE_BRACE);
IDENT_VIS : SYMBOL OPERATOR? ;
IDENT_PRAGMA : IDENT_VIS PRAGMA? ; 
// TRY_EXPR: TRY COLCOM STMT &(OPT_IND EXCEPT|FINALLY)
//           (OPT_IND EXCEPT EXPR_LIST COLCOM STMT)*
//           (OPT_IND FINALLY COLCOM STMT)? ;

EXPR_LIST: EXPR (COMMA EXPR)*;

WHEN_STMT: WHEN COND_STMT;
WHILE_STMT: WHILE EXPR COLCOM STMT;
TRY_STMT: TRY COLCOM STMT 
           (INDENT{=}? EXCEPT EXPR_LIST COLCOM STMT)*
           (INDENT{=}? FINALLY COLCOM STMT)? ; 
FOR_STMT: FOR IDENT_PRAGMA (COMMA IDENT_PRAGMA)* IN EXPR COLCOM STMT ;
BLOCK_STMT: BLOCK SYMBOL? COLCOM STMT;
STATIC_STMT: STATIC COLCOM STMT;
DEFER_STMT: DEFER COLCOM STMT;
ASM_STMT: ASM PRAGMA? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT);

SYMBOL : '`' (KEYW|IDENTIFIER|LITERAL|(OPERATOR|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`' | IDENTIFIER | KEYW ;
STMT: 
    IMPORT_STMT 
    | TRY_STMT
    | ASM_STMT 
    | CASE_STMT;

CASE_STMT : CASE EXPR ':'? COMMENT?;
IMPORT_STMT: 
    IMPORT IDENTIFIER (',' IDENTIFIER)* | IMPORT IDENTIFIER FROM IDENTIFIER ;
COMMENT: MULTI_LINE_COMMENT | SINGLE_LINE_COMMENT ;
IND_COMMENT : (INDENT{>} COMMENT)? | COMMENT?;
SINGLE_LINE_COMMENT:
    '#' ~('\r' | '\n' | '#')* -> skip ;
MULTI_LINE_COMMENT:
    INDENT* (HASHTAG OPEN_BRACK (ANY)* CLOSE_BRACK HASHTAG 
    |HASHTAG HASHTAG OPEN_BRACK (ANY)* CLOSE_BRACK HASHTAG HASHTAG) -> skip ;
ADDR_OPER: 
    ADDR OPEN_PAREN IDENTIFIER CLOSE_PAREN ;
//TRY_STMT:
  //  TRY COLON ;
//ASM_STMT:
  //  ASM (STR_LIT | RSTR_LIT | TRIPLESTR_LIT) ;
BIND_STMT:
    BIND;
CAST_EXPR: 
    CAST;

GEN_LIT : GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT ;
IDENT_LIT : GEN_LIT | SYMBOL | LITERAL
            | PAR 
            //| arrayConstr | setOrTableConstr
            | CAST_EXPR;

TYPE_KEYW : VARIABLE | OUT | REF | PTR | SHARED | TUPLE | PROC | ITERATOR | DISTINCT | OBJECT | ENUM ;
PAR_KEYW : DISCARD | INCLUDE | IF | WHILE | CASE | TRY | FINALLY | EXCEPT | FOR | BLOCK 
        | CONST | LET | WHEN | VARIABLE | MIXIN ;


PAR : OPEN_PAREN OPT_IND
    ( PAR_KEYW CMPLX_SIMPLE_STMT (SEMI_COLON PAR_KEYW CMPLX_SIMPLE_STMT)+
    | SEMI_COLON CMPLX_SIMPLE_STMT (SEMI_COLON CMPLX_SIMPLE_STMT)*
    | PRAGMA_STMT
    // simple_expr op0
    | ASSIGN_EXPR ( ('=' EXPR (SEMI_COLON CMPLX_SIMPLE_STMT (SEMI_COLON SEMI_COLON CMPLX_SIMPLE_STMT)+)? )
    | (SEMI_COLON EXPR (COMMA EXPR_COLON_EXPR (COMMA COMMA EXPR_COLON_EXPR)*)? ) ) )OPT_PAR CLOSE_PAREN;
PRAGMA_STMT: PRAGMA (SEMI_COLON COMMENT? STMT)? ;

//^*
GENERIC_PARAM : SYMBOL (COMMA SYMBOL)* (COLON EXPR)? ('=' OPT_IND EXPR)?;
GENERIC_PARAM_LIST : OPEN_BRACK OPT_IND
  GENERIC_PARAM (COMMA GENERIC_PARAM|SEMI_COLON GENERIC_PARAM)* OPT_PAR CLOSE_BRACK;
PARAM_LIST : OPEN_PAREN DECL_COLON_EQUALS (COMMA DECL_COLON_EQUALS|SEMI_COLON DECL_COLON_EQUALS)* CLOSE_PAREN;

DECL_COLON_EQUALS: IDENT_PRAGMA (COMMA IDENT_PRAGMA)* COMMA?
                  (COLON OPT_IND ASSIGN_EXPR)? ('=' OPT_IND EXPR)?;
                  
//ssimple_expr
PARAM_LIST_COLON : PARAM_LIST? (COLON OPT_IND ASSIGN_EXPR)?;
PATTERN : OPEN_BRACE STMT CLOSE_BRACE;

ROUTINE :  OPT_IND IDENT_VIS PATTERN? GENERIC_PARAM_LIST?
  PARAM_LIST_COLON PRAGMA? ('=' COMMENT? STMT)? IND_COMMENT;

CMPLX_SIMPLE_STMT : IF_STMT | WHEN_STMT | WHILE_STMT
                    | TRY_STMT | FOR_STMT | BLOCK_STMT | STATIC_STMT | DEFER_STMT | ASM_STMT
                    | PROC ROUTINE
                    | METHOD ROUTINE
                    | ITERATOR ROUTINE
                    | MACRO ROUTINE
                    | TEMPLATE ROUTINE
                    | CONVERTER ROUTINE
                 //   | TYPE section(typeDef)
                  //  | CONST section(constant)
                    //| (LET | VAR | USING) section(variable)
                    //| bindStmt | mixinStmt)
                    | SIMPLE_STMT;
SIMPLE_STMT: ((RETURN_STMT | RAISE_STMT | YIELD_STMT | DISCARD_STMT | BREAK_STMT
           | CONT_STMT | PRAGMA_STMT | IMPORT_STMT 
           //| EXPORT_STMR 
           | FROM_STMT
           | INCLUDE_STMT | COMMENT) 
           //| EXPR_STMT
           ) 
           COMMENT?;

RETURN_STMT: RETURN OPT_IND EXPR?;
RAISE_STMT: RAISE OPT_IND EXPR?;
YIELD_STMT: YIELD OPT_IND EXPR?;
DISCARD_STMT: DISCARD OPT_IND EXPR? ;
BREAK_STMT: BREAK OPT_IND EXPR? ;
CONT_STMT: CONTINUE OPT_IND EXPR? ;
FROM_STMT: FROM IDENTIFIER IMPORT OPT_IND EXPR (COMMA EXPR)*;
INCLUDE_STMT: INCLUDE OPT_IND EXPR (COMMA EXPR)*;
//EXPR_STMT: ASSIGN_EXPR
  //       (( '=' OPT_IND EXPR colonBody? )
    //     |( EXPR (COMMA EXPR)+
      //       doBlocks
        //    |macroColon
          // ))?;


SHARED : 'shared' ;
HASHTAG: '#' ;
AND: 'and' ;
VARIABLE: 'var' ;
KEYW : ADDR | AS | ASM | BIND | BLOCK | BREAK | CASE | CAST | CONCEPT | CONST | CONTINUE | CONVERTER
    | DEFER | DISCARD | DISTINCT | DIV | DO | ELIF | ELSE | END | ENUM | EXCEPT | EXPORT | FINALLY
    | FOR | FROM | FUNC | IF | IMPORT | IN | INCLUDE | INTERFACE | IS | ISNOT | ITERATOR | LET 
    | MACRO | METHOD | MIXIN | MOD | NIL | NOTIN | OBJECT | OF | OR | OUT | PROC | PTR | RAISE | REF
    | RETURN | SHL | SHR | STATIC | TEMPLATE | TRY | TUPLE | TYPE | USING | VARIABLE | WHEN | WHILE
    | XOR | YIELD ;

ADDR: 'addr';
AS: 'as' ;
ASM: 'asm' ;
BIND: 'bind' ;
BLOCK: 'block' ;
BREAK: 'break' ;
CASE: 'case' ;
CAST: 'cast' ;
CONCEPT: 'concept' ;
CONST: 'const' ;
CONTINUE: 'continue' ;
CONVERTER: 'converter' ;
DEFER: 'defer' ;
DISCARD: 'discard' ;
DISTINCT: 'distinct' ;
DIV: 'div' ;
DO: 'do' ;
ELIF: 'elif' ;
ELSE: 'else' ;
END: 'end' ;
ENUM: 'enum' ;
EXCEPT: 'except' ;
EXPORT: 'export' ;
FINALLY: 'finally' ;
FOR: 'for' ;
FROM: 'from' ;
FUNC: 'func' ;
IF: 'if' ;
IMPORT: 'import' ;
IN: 'in' ;
INCLUDE: 'include' ;
INTERFACE: 'interface' ;
IS: 'is' ;
ISNOT: 'isnot' ;
ITERATOR: 'iterator' ;
LET: 'let' ;
MACRO: 'macro' ;
METHOD: 'method' ;
MIXIN: 'mixin' ;
MOD: 'mod' ;
NIL: 'nil' ;
NOT: 'not' ;
NOTIN: 'notin' ;
OBJECT: 'object' ;
OF: 'of' ;
OR: 'or' ;
OUT: 'out' ;
PROC: 'proc' ;
PTR: 'ptr' ;
RAISE: 'raise' ;
REF: 'ref' ;
RETURN: 'return' ;
SHL: 'shl' ;
SHR: 'shr' ;
STATIC: 'static' ;
TEMPLATE: 'template' ;
TRY: 'try' ;
TUPLE: 'tuple' ;
TYPE: 'type' ;
USING: 'using' ;
WHEN: 'when' ;
WHILE: 'while' ;
XOR: 'xor' ;
YIELD: 'yield' ;
IDENTIFIER : LETTER+ ( '_'?(LETTER | DIGIT) )*;
LETTER: [a-zA-Z] ;
DIGIT: [0-9] ;
LITERAL: 
    INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
    | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
    | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
    | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
    | CHAR_LIT
    | NIL ;
INT_LIT:
         HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT ;
HEX_LIT : '0' ('x' | 'X' ) HEXDIGIT+ ( '_' HEXDIGIT )* ;
DEC_LIT : DIGIT+ ( '_' DIGIT+ )* ;
OCT_LIT : '0' 'o' OCTDIGIT+ ( '_' OCTDIGIT )* ;
BIN_LIT : '0' ('b' | 'B' ) BINDIGIT+ ( '_' BINDIGIT+ )*  ;
INT8_LIT: INT_LIT '\'' ('i' | 'I') '8' ;
INT16_LIT: INT_LIT '\'' ('i' | 'I') '16' ;
INT32_LIT: INT_LIT '\'' ('i' | 'I') '32' ;
INT64_LIT: INT_LIT '\'' ('i' | 'I') '64' ;
UINT_LIT: INT_LIT '\'' ('u' | 'U') ;
UINT8_LIT: UINT_LIT '8' ;
UINT16_LIT: UINT_LIT '16' ;
UINT32_LIT: UINT_LIT '32' ;
UINT64_LIT: UINT_LIT '64' ;
FLOAT_LIT: DIGIT+ ('_' DIGIT)* (('.' DIGIT+ ('_' DIGIT)* EXP?) |EXP);
FLOAT32_LIT: HEX_LIT '\'' FLOAT32_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) '\'' FLOAT32_SUFFIX ;
FLOAT32_SUFFIX:  ('f' | 'F') '32' ;
FLOAT64_LIT: HEX_LIT '\'' FLOAT64_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) '\'' FLOAT64_SUFFIX ;
FLOAT64_SUFFIX: ( ('f' | 'F') '64' ) | 'd' | 'D' ; 
EXP: ('e' | 'E' ) [+-] DIGIT+ ( [_] DIGIT )* ;
HEXDIGIT: DIGIT | [A-Fa-f] ;
OCTDIGIT: [0-7] ;
BINDIGIT: [0-1] ;
EQUALS_OPERATOR: '=''='? ;
LE_OPERATOR: LESS_THAN '=' ;
GE_OPERATOR: GREATER_THAN '=' ;
ADD_OPERATOR: '+' ;
MUL_OPERATOR: '*' ;
MINUS_OPERATOR: '-' ;
DIV_OPERATOR: '/' ;
BITWISE_NOT_OPERATOR: '~' ;
AND_OPERATOR: '&' ;
OR_OPERATOR: '|' ;
LESS_THAN: '<' ;
GREATER_THAN: '>' ;
AT: '@' ;
MODULUS: '%';
NOT_OPERATOR: '!';
XOR_OPERATOR: '^';
DOT: '.' ;
COLON: ':' ;
OPEN_PAREN: '(' ;
CLOSE_PAREN: ')' ;
OPEN_BRACE: '{' ;
CLOSE_BRACE: '}' ;
OPEN_BRACK: '[' ;
CLOSE_BRACK: ']' ;
COMMA: ',' ;
SEMI_COLON: ';' ;
DOLLAR : '$' ;
CHAR_LIT: '\'\\t\'' | '\'\\r\'' | '\'\\c\'' | '\'\\n\'' | '\'\\l\'' | '\'\\f\''  | '\'\\v\'' | '\'\\\\\'' | '\'\\"\'' | '\'\\\'\'' | '\'\\a\'' | '\'\\b\'' | '\'\\e\'' | '\'\\x\'' | ('\'' [0-9a-zA-Z] '\'') ;
STR_LIT: '"' ( ~["\n\r\u2028\u2029])* '"' ;
TRIPLESTR_LIT:'"""' ANY* '"""';
RSTR_LIT: 'r' '"' ( '\\' [btnfr"'\\] | ~[\r\n\\"] )* '"';
GENERALIZED_STR_LIT: IDENTIFIER STR_LIT;
GENERALIZED_TRIPLESTR_LIT: IDENTIFIER TRIPLESTR_LIT;

stmt :  (INDENT{>} CMPLX_SIMPLE_STMT (INDENT{=} CMPLX_SIMPLE_STMT| SEMI_COLON CMPLX_SIMPLE_STMT)*)
     | SIMPLE_STMT (SEMI_COLON SIMPLE_STMT)*; 

ANY: . -> skip;